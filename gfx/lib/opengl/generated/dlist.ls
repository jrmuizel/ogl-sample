
#
# License Applicability. Except to the extent portions of this file are
# made subject to an alternative license as permitted in the SGI Free
# Software License B, Version 1.0 (the "License"), the contents of this
# file are subject only to the provisions of the License. You may not use
# this file except in compliance with the License. You may obtain a copy
# of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
# Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
# 
# http://oss.sgi.com/projects/FreeB
# 
# Note that, as provided in the License, the Software is distributed on an
# "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
# DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
# CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
# PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
# 
# Original Code. The Original Code is: OpenGL Sample Implementation,
# Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
# Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
# Copyright in any portions created by third parties is as indicated
# elsewhere herein. All Rights Reserved.
# 
# Additional Notice Provisions: The application programming interfaces
# established by SGI in conjunction with the Original Code are The
# OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
# April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
# 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
# Window System(R) (Version 1.3), released October 19, 1998. This software
# was created using the OpenGL(R) version 1.2.1 Sample Implementation
# published by SGI, but has not been independently verified as being
# compliant with the OpenGL(R) version 1.2.1 Specification.
#

# $Date$ $Revision$
# $Header: //depot/main/gfx/lib/opengl/generated/dlist.ls#7 $

#
# Generate header files related to the dispatch tables.  The dispatch
# tables only contain entries that are display listable.  Things which
# are immediate mode only will not be represented here. For example:
# any of the gets, glNewList,  glPixelStoref, etc.
#

function initialize()
{
    typeMapFile = TYPEMAP;
    _readWireFile();

    # What kind of output is desired
    output = OUTPUT;

    outputHeader = (output ~ /g_lcomp_h/);
    outputCompile = (output ~ /g_lcomp_c/);
    outputSPComp = (output ~ /g_splcmp_c/);
    outputCaEFuncs = (output ~ /g_lcompex_funcs/);
    outputCaETable = (output ~ /g_lcompex_table/);
    outputApiTable = (output ~ /g_api_table/);
    outputExecute = (output ~ /g_lexec_c/);
    outputSPheader = (output ~ /g_splcfs_h/);

    #
    # Partial names of macros used to send each wire type.
    #
    cast["enum"] =      "LONG"
    cast["boolean"] =   "CHAR"
    cast["bitfield"] =  "LONG"
    cast["byte"] =      "CHAR"
    cast["short"] =     "SHORT"
    cast["int"] =       "LONG"
    cast["sizei"] =     "LONG"
    cast["ubyte"] =     "CHAR"
    cast["ushort"] =    "SHORT"
    cast["uint"] =      "LONG"
    cast["float"] =     "FLOAT"
    cast["clampf"] =    "FLOAT"
    cast["double"] =    "DOUBLE"
    cast["clampd"] =    "DOUBLE"
    cast["void"] =      "VOID"

    #
    # Byte sizes of implementation types.
    #
    xfer_size["enum"] =         "4"
    xfer_size["boolean"] =      "1"
    xfer_size["bitfield"] =     "4"
    xfer_size["byte"] =         "1"
    xfer_size["short"] =        "2"
    xfer_size["int"] =          "4"
    xfer_size["sizei"] =        "4"
    xfer_size["ubyte"] =        "1"
    xfer_size["ushort"] =       "2"
    xfer_size["uint"] =         "4"
    xfer_size["float"] =        "4"
    xfer_size["clampf"] =       "4"
    xfer_size["double"] =       "8"
    xfer_size["clampd"] =       "8"
    xfer_size["void"] =         "1"     # A lie, but it works

    print "/* This file generated by dlist.ls -- DO NOT EDIT! */"

    if (outputCompile || outputExecute || outputSPComp || outputCaETable ||
	outputCaEFuncs) {
	if (outputCaETable || outputCaEFuncs || outputSPComp)
	    printf("#ifdef NEW_LISTS\n\n");
	printf("#include \"context.h\"\n");
	printf("#include \"global.h\"\n");
	printf("#include \"dlist.h\"\n");
	printf("#include \"dlistopt.h\"\n");
	printf("#include \"g_lcomp.h\"\n");
	if (outputSPComp)
	    printf("#include \"g_splcfs.h\"\n");
	printf("#include \"g_listop.h\"\n");
	printf("#include \"g_imports.h\"\n");
	printf("#include \"g_lcefncs.h\"\n");
	printf("#include \"g_lcomp.h\"\n");
	printf("\n");
    }
    if (outputHeader) {
	printf("#define __GL_PAD(x) (4 * (((x) + 3) / 4))\n");
	printf("\n");
    }

    if (outputSPComp) {
	printf("extern GLvoid *__glSPDlalloc(GLint size, GLint func);\n");
	printf("extern GLvoid *__glSPDlalloc2(GLint size, GLint func);\n\n");
	printf("extern GLvoid __glsplc_InvalidEnum(GLvoid);\n\n");
	printf("extern GLvoid __glsplc_InvalidValue(GLvoid);\n\n");
    }

    supportDoubles = 1;		# don't coerce all double precision to float
}

##############################################################################
#
# Compute the size of a command.
#
# Variables modified:
#	_alen[]		 size, in bytes, of each array
#	_acount[]	 size, in element count, of each array
#	varparam	 parameter number which is variable size
#
##############################################################################
function computeInCmdSize(client_transport)
{
    numInVarParams = 0;
    _inVarParamOffset = "";
    for (i=1; i<=paramCount; i++) {
	param = paramName[i];
	dtype = paramDeclaredType[param];
	ttype = paramTransferType[param];
	udtype = paramUnmappedDeclaredType[param];
	dim = paramDimensions[param];

	# Is it a fixed or variable sized command?
	if (isarray[i]) {
	    if (dim == 1) {
		len1 = paramSubscripts[param,1];
		if (inParamOptions(param,"retval")) {
		    len1 = "retval";
		} else if ( len1 ~ /COMPSIZE/) {
		    # strip away everything but the params
		    tmp = len1;
		    gsub(/[-+\/*(),\[\]]/, " ", tmp);
		    sub( "COMPSIZE", "", tmp);
		    gsub( " ", ",", tmp);
		    len1 = "__gl" functionName "_size(" tmp ")";
		    gsub( /\(,/, "(", len1);
		    gsub( /,\)/, ")", len1);
		} 
		if (_varsize[i]) {
		    varparam = i;
		    _acount[i] = sprintf("%s", len1);
		    inVarParamOffset[i] = _inVarParamOffset;
		    _inVarParamOffset = sprintf("%s + arraySize%d", 
					_inVarParamOffset, numInVarParams);
		    inVarParams[numInVarParams++] = i;
		} else {
		    _acount[i] = sprintf("%d", len1);
		}
	    } else {
		len1 = paramSubscripts[param,1];
		len2 = paramSubscripts[param,2];
		if (_varsize[i]) {
		    _acount[i] = sprintf( "%s*%s", len1, len2);
		} else {
		    _acount[i] = sprintf("%d", len1*len2);
		}
	    }
	}
    }
}

##############################################################################
#
# Set some flags for each parameter so they can be conveniently used in the
# rest of the script.
#
# Variables modified:
#	_varsize[]	Boolean: whether each parameter is variable sized
#	varsize		Boolean: whether the entire command is variable sized
#	isarray[]	Boolean: whether each parameter is an array
#	_cast[]		string name of macro used to write each parameter
#	_wire[]		wire type of each parameter
#	_xfer_size[]	transfer size, in bytes, of each parameter
#	nscalars	number of scalar params
#	narray		number of array params
#
##############################################################################
function setPerParamFlags(i,len1,len2)
{

    varsize = false;	# true if a variable sized command
    needAlign = false;	# true if any doubles in param list

    for (i=1; i<=paramCount; i++) {
	param = paramName[i];
	dtype = paramDeclaredType[param];
	ttype = paramTransferType[param];
	udtype = paramUnmappedDeclaredType[param];
	dim = paramDimensions[param];

	paramLookup[param] = i;

	# always set this - whether we are coercing to floats or not
	if (dtype == "GLdouble" || dtype == "GLclampd")  needAlign = true;

	# Get the wiretype.
	if (udtype in wiretype) {
	    _wire[i] = wiretype[udtype]
	} else {
	    specError("wiretype[] has no map for " udtype)
	    exit 1
	}

	# Get the cast string.
	if (_wire[i] in cast) {
	    _cast[i] = cast[_wire[i]];
	} else {
	    specError("cast[] has no map for " udtype)
	    exit 1
	}

	# Get the transfer size.
	if (_wire[i] in xfer_size) {
	    _xfer_size[i] = xfer_size[_wire[i]];
	} else {
	    specError("xfer_size[] has no map for " udtype)
	    exit 1
	}

	# Is it a fixed or variable sized command?
	if (ttype == "array") {	
	    isarray[i] = 1;

	    if (dim == 1) {
		len1 = paramSubscripts[param,1];
		if (len1 ~ /^[0-9]+$/) {
		    _varsize[i] = false;
		} else {
		    _varsize[i] = true;
		    varsize = true;
		}
	    } else {
		len1 = paramSubscripts[param,1];
		len2 = paramSubscripts[param,2];
		if (len1 ~ /^[0-9]+$/ && len2 ~ /^[0-9]+$/) {
		    _varsize[i] = false;
		} else {
		    _varsize[i] = true;
		    varsize = true;
		}
	    }
	} else {
	    isarray[i] = 0;
	    _varsize[i] = false;
	}
    }
}

##############################################################################
#
# Builds a structure describing what the stored display list data looks like.
#
##############################################################################
function buildProtocolStruct(padcount, curcount, entries, s, i)
{
    padcount = 0;
    curcount = 0;
    entries = 0;

    printf("struct __gllc_%s_Rec {\n", functionName);
    # Sort fixed size params (scalars or arrays) from largest to smallest.
    numInFixedSizeParams = 0;
    sortSizes[1] = 8;
    sortSizes[2] = 4;
    sortSizes[3] = 2;
    sortSizes[4] = 1;
    sortType[1] = "GLdouble";
    sortType[2] = "GLuint";
    sortType[3] = "GLushort";
    sortType[4] = "GLubyte";

    for (s=1; s<=4; s++) {
        for (i=1; i<=paramCount; i++) {
            param = paramName[i];
	    _ptype = paramDeclaredType[param];
	    if (!supportDoubles) {
		if (_ptype == "GLdouble") _ptype = "GLfloat";
		if (_ptype == "GLclampd") _ptype = "GLclampf";
	    }
            if (_varsize[i]) continue;
            if (_xfer_size[i] == sortSizes[s]) {
		if (isarray[i]) {
		    # Add this one to the struct
		    entries += _acount[i];
		    curcount += _acount[i] * sortSizes[s];
		    printf("\t%s\t%s[%d];\n", _ptype, param, 
			    _acount[i]);
		} else {
		    # Add this one to the struct
		    entries++;
		    curcount+=sortSizes[s];
		    printf("\t%s\t%s;\n", _ptype, param);
		}
            }
        }
	curcount = 4 - (curcount % 4);
	if (curcount == 4) curcount = 0;
	while (curcount) {
	    entries++;
	    padcount++;
	    printf("\t%s\tpad%d;\n", sortType[s], padcount);
	    curcount -= sortSizes[s];
	}
    }
    for (i=1; i<=paramCount; i++) {
	param = paramName[i];
	if (_varsize[i]) {
	    printf("\t/*\t%s\t*/\n", param);
	}
    }
    if (entries == 0) {
	if (paramCount > 0) {
	    printf("\n");
	}
	printf("\t/* pad is here so the struct has at least one entry */\n");
	printf("\tGLuint\tpad;\n");
    }
    printf("};\n");
}

##############################################################################
#
# Compute the size of the operation.
#
##############################################################################
function calcSizes()
{
    tmp = _acount[varparam];
    if (outputExecute) {
	if (index(tmp, "_size") == 0) {
	    tmp = "data->" tmp;
	} else {
	    sub(/\(/, "(data->", tmp);
	    gsub(/,/, ",data->", tmp);
	}
    }
    # varparam is the variable parameter
    if (_xfer_size[varparam] == 2) {
	printf("    arraySize = __GL_PAD(%s * %d);\n", tmp,
		_xfer_size[varparam]);
    } else if (_xfer_size[varparam] == 1) {
	printf("    arraySize = __GL_PAD(%s);\n", tmp);
    } else {
	printf("    arraySize = __GL64PAD(%s * %d);\n", tmp,
		_xfer_size[varparam]);
    }
    # if arraySize is computed using a *_size() function, then errors are
    # enum-type errors; otherwise they are value-type errors.
    if(outputCompile || outputSPComp) { # no error checking for execution routines
	if(tmp ~ /_size/) { 
	    if (outputCompile) err = "__gllc_InvalidEnum(gc)"; else err = "__glsplc_InvalidEnum()";
	} else {
	    if (outputCompile) err = "__gllc_InvalidValue(gc)"; else err = "__glsplc_InvalidValue()";
	}
	printf("    if (arraySize < 0) {\n        %s;\n        return;\n    }\n", err);
    }
    printf("    size = (GLuint)sizeof(struct __gllc_%s_Rec) + arraySize;\n",
	functionName);
}

function calcMultVarSizes()
{
    _current_offset = "";
    for (i=0; i<numInVarParams; i++) {
	tmp = _acount[inVarParams[i]];
	if (outputExecute) {
	    if (index(tmp, "_size") == 0) {
		tmp = "data->" tmp;
	    } else {
		sub(/\(/, "(data->", tmp);
		gsub(/,/, ",data->", tmp);
	    }
	}

	# i is the variable parameter
	if (_xfer_size[inVarParams[i]] == 2) {
	    printf("    arraySize%d = __GL_PAD(%s * %d);\n",
				i, tmp, _xfer_size[inVarParams[i]]);
	} else if (_xfer_size[inVarParams[i]] == 1) {
	    printf("    arraySize%d = __GL_PAD(%s);\n", i, tmp);
	} else {
	    printf("    arraySize%d = __GL64PAD(%s * %d);\n",
				i, tmp, _xfer_size[inVarParams[i]]);
	}
	# if arraySize is computed using a *_size() function, then errors are
	# enum-type errors; otherwise they are value-type errors.
	if(outputCompile) { # no error checking for execution routines
	    if(tmp ~ /_size/) { 
		if (outputCompile) err = "__gllc_InvalidEnum(gc)"; else err = "__glsplc_InvalidEnum()";
	    } else {
		if (outputCompile) err = "__gllc_InvalidValue(gc)"; else err = "__glsplc_InvalidValue()";
	    }
		printf("    if (arraySize%d < 0) {\n        %s;\n        return;\n    }\n", i, err);
	}
	if (i == 0) {
	    _current_offset = sprintf("arraySize%d", i);
	} else {
	    inVarParamOffset[inVarParams[i]] = " + " _current_offset;
	    _current_offset = sprintf("%s + arraySize%d", _current_offset, i);
	}
    }
    printf("    size = (GLuint)sizeof(struct __gllc_%s_Rec) + %s;\n",
	    functionName, _current_offset);
}

function makeVectorArgs()
{
    vArgList = "";
    if (paramCount == 0) {
        vArgList = "void";
    } else {
        for (i=1; i<paramCount; i++) {
	    vArgList = vArgList paramName[i] ", ";
	}
	vArgList = vArgList "&" paramName[i];
    }
    printf("%s",vArgList);
}

function output_header() {
    printf("\n");
    if (paramCount > 0) {
	buildProtocolStruct();
    }
    printf("extern void GLAPI __gllc_%s(", functionName);
    outputCArglist();
    printf(");\n");
    if (!("vectorequiv" in propList)) {
	printf("extern const GLubyte *__glle_%s(const GLubyte *);\n", 
		functionName);
    }
    if (handcode) return;
    if (varsize && index(_acount[varparam], "_size") != 0) {
	printf("extern GLint __gl%s_size(", functionName);
	tmp = _acount[varparam];
	sub(/__gl.*_size\(/, "", tmp);
	sub(/\)/, "", tmp);
	while (length(tmp) > 0) {
	    offset = index(tmp, ",");
	    if (offset == 0) offset = length(tmp)+1;
	    param = substr(tmp, 1, offset-1);
	    tmp = substr(tmp, offset+1, length(tmp)-offset+1);
	    i = paramLookup[param];
	    if (i >= 1 && i <= paramCount) {
		printf("%s %s", paramDeclaredType[param], param);
	    } else {
		printf("/* %s? */ ", param);
	    }
	    if (length(tmp) > 0) {
		printf(", ");
	    }
	}
	printf(");\n");
    }
    return;
}

function output_execute() {
    printf("const GLubyte *__glle_%s(const GLubyte *PC)\n", functionName);
    printf("{\n");
    if (varsize) {
	printf("    GLuint size;\n");
	if (numInVarParams > 1) {
	    for (i=0; i<numInVarParams; i++) {
		printf("    GLuint arraySize%d;\n", i);
	    }
	} else {
	    printf("    GLuint arraySize;\n");
	}
    }
    if (paramCount > 0) {
	printf("    const struct __gllc_%s_Rec *data;\n", functionName);
    }
    printf("\n");
    if (paramCount > 0) { 
	printf("    data = (const struct __gllc_%s_Rec *) PC;\n",
		functionName);
    } 
    if (varsize) {
	if (numInVarParams > 1) {
	    calcMultVarSizes();
	}
    }
    printf("    (*__gl_dispatch.dispatch.%s)(", functionName);
#	printf("    __glim_%s(", functionName);
    for (i=1; i<=paramCount; i++) {
	param = paramName[i];
	if (_varsize[i]) {
	    if (numInVarParams > 1) {
		printf("\n\t    (const %s *) ", paramDeclaredType[param]);
		printf("(PC + sizeof(struct __gllc_%s_Rec)", functionName);
		printf("%s)", inVarParamOffset[i]);
	    } else {
		printf("\n\t    (const %s *) (PC + sizeof(struct __gllc_%s_Rec))", 
		    paramDeclaredType[param], functionName);
	    }
	} else {
	    if (i % 5 == 0) {
		printf("\n\t    ");
	    }
	    printf("data->%s", param);
	}
	if (i != paramCount) {
	    printf(", ");
	}
    }
    printf(");\n");
    if (varsize) {
	if (numInVarParams <= 1) {
	    calcSizes();
	}
	printf("    return PC + size;\n");
    } else {
	if (paramCount > 0) {
	    printf("    return PC + sizeof(struct __gllc_%s_Rec);\n",
		    functionName);
	} else {
	    printf("    return PC;\n");
	}
    }
    printf("}\n\n");
}

function output_compile() {
    printf("void GLAPI __gllc_%s(", functionName);
    outputCArglist();
    printf(")\n");
    printf("{\n");
    if (useVectorEquiv) {
	printf("    __GL_SETUP();\n\n");
	printf("    if (__gl%sv_size(pname) != 1) {\n",functionName);
	printf("      __gllc_InvalidEnum(gc);\n");
	printf("      return;\n");
	printf("    }\n");
	printf("    __gllc_%sv(",functionName);
	makeVectorArgs();
	printf(");\n");
	printf("}\n\n");
	return;
    }
    printf("    __GLdlistOp *dlop;\n");
    if (varsize) {
	printf("    GLuint size;\n");
	if (numInVarParams > 1) {
	    for (i=0; i<numInVarParams; i++) {
		printf("    GLint arraySize%d;\n", i);
	    }
	} else {
	    printf("    GLint arraySize;\n");
	}
    }
    if (errorCheckMat) {
	printf("    GLenum error;\n");
    }
    if (paramCount > 0) {
	printf("    struct __gllc_%s_Rec *data;\n", functionName);
    }
    printf("    __GL_SETUP();\n");
    printf("\n");
    if (errorCheckMat) {
	printf("    error=__glErrorCheckMaterial(%s, %s, %s[0]);\n",
		paramName[1], paramName[2], paramName[3]);
	printf("    if(error!=GL_NO_ERROR) {\n");
	printf("      __gllc_Error(gc,error);\n");
	printf("      return;\n");
	printf("    }\n");		      
    }
    # compute size somehow.
    if (varsize) {
	if (numInVarParams > 1) {
	    calcMultVarSizes();
	} else {
	    calcSizes();
	}
	printf("    dlop = __glDlistAllocOp2(gc, size);\n");
    } else {
	if (paramCount > 0) {
	    printf("    dlop = __glDlistAllocOp2(gc, sizeof(struct __gllc_%s_Rec));\n",
		    functionName);
	} else {
	    printf("    dlop = __glDlistAllocOp2(gc, 0);\n");
	}
    }
    printf("    if (dlop == NULL) return;\n");

    if ("vectorequiv" in propList) {
	opcodeName = propList["vectorequiv"];
	sub( ",", "", opcodeName);
    } else {
	opcodeName = functionName;
    }
    # change dv vector routines to fv
    if (!supportDoubles && needAlign)
	sub( "dv", "fv", opcodeName);

    printf("    dlop->opcode = __glop_%s;\n", opcodeName);
    if (supportDoubles && needAlign)
	printf("    dlop->aligned = GL_TRUE;\n");

    if (paramCount > 0) {
	printf("    data = (struct __gllc_%s_Rec *) dlop->data;\n", 
		functionName);
	for (i=1; i<=paramCount; i++) {
	    param = paramName[i];
	    if (_varsize[i]) continue;
	    if (isarray[i]) {
		if (_acount[i] + 0 <= 4) { # coerce _acount[] to number
		    # few enough entries we inline copy them
		    for (j=0; j<_acount[i]; j++) {
			printf("    data->%s[%d] = %s[%d];\n", param, j, 
				param, j);
		    }
		} else {
		    # Just copy the array
		    printf("    __GL_MEMCOPY(data->%s, %s, (int)sizeof(data->%s));\n", 
			    param, param, param);
		}
	    } else {
		printf("    data->%s = %s;\n", param, param);
	    }
	}
	if (varsize) {
	    # Copy the array
	    if (numInVarParams > 1) {
		for (i=0; i<numInVarParams; i++) {
		    printf("    __GL_MEMCOPY(dlop->data + ");
		    printf("(int)sizeof(struct __gllc_%s", functionName);
		    printf("_Rec)%s,\n\t    ", 
					inVarParamOffset[inVarParams[i]]);
		    printf("%s, arraySize%d);\n",paramName[inVarParams[i]],i);
		}
	    } else {
		printf("    __GL_MEMCOPY(dlop->data + ");
		printf("(int)sizeof(struct __gllc_%s", functionName);
		printf("_Rec),\n\t    %s, arraySize);\n", paramName[varparam]);
	    }
	}
    }
    if (functionName ~ /^Vertex[234]/) {
	printf("    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_VERTEX;\n");
    } else if (functionName ~ /^Color[34]/) {
	printf("    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_COLOR;\n");
    } else if (functionName ~ /^Index[dfis]/) {
	printf("    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_INDEX;\n");
    } else if (functionName ~ /^Normal3/) {
	printf("    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_NORMAL;\n");
    } else if (functionName ~ /^TexCoord[1234]/) {
	printf("    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_TEXCOORDS;\n");
    } else if (functionName ~ /^MultiTexCoord[1234]/) {
	# This might need to be a different flag from regular TexCoord,
	# or no flag at all.
	printf("    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_TEXCOORDS;\n");
    } else if (functionName ~ /^RasterPos[234]/) {
	printf("    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_RASTERPOS;\n");
    } else if (functionName ~ /^Rect[dfis]/) {
	printf("    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_RECT;\n");
    } else if (functionName ~ /^Material[if]v/) {
	printf("    gc->dlist.listData.genericFlags |= __GL_DLFLAG_HAS_MATERIAL;\n");
    }

    printf("    __glDlistAppendOp(gc, dlop, __glle_%s);\n", opcodeName);
    printf("}\n\n");
}

function output_compile_SP() {
    printf("void GLAPI __glsplc_%s(", functionName);
    outputCArglist();
    printf(")\n");
    printf("{\n");
    if (useVectorEquiv) {
	printf("    if (__gl%sv_size(pname) != 1) {\n",functionName);
	printf("      __glsplc_InvalidEnum();\n");
	printf("      return;\n");
	printf("    }\n");
	printf("    __glsplc_%sv(",functionName);
	makeVectorArgs();
	printf(");\n");
	printf("}\n\n");
	return;
    }
    if (varsize) {
	printf("    GLuint size;\n");
	if (numInVarParams > 1) {
	    for (i=0; i<numInVarParams; i++) {
		printf("    GLint arraySize%d;\n", i);
	    }
	} else {
	    printf("    GLint arraySize;\n");
	}
    }
    if (errorCheckMat) {
	printf("    GLenum error;\n");
    }
    if (paramCount > 0)
	printf("    struct __gllc_%s_Rec *data;\n", functionName);
    else
	printf("    GLvoid *data;\n");

    printf("\n");
    if (errorCheckMat) {
	printf("    error=__glErrorCheckMaterial(%s, %s, %s[0]);\n",
		paramName[1], paramName[2], paramName[3]);
	printf("    if(error!=GL_NO_ERROR) {\n");
	printf("      __GL_SETUP();\n");
	printf("      __gllc_Error(gc,error);\n");
	printf("      return;\n");
	printf("    }\n");		      
    }

    if ("vectorequiv" in propList) {
	opcodeName = propList["vectorequiv"];
	sub( ",", "", opcodeName);
    } else {
	opcodeName = functionName;
    }
    # change dv vector routines to fv
    if (!supportDoubles && needAlign)
	sub( "dv", "fv", opcodeName);

    # compute size somehow.
    if (varsize) {
	if (numInVarParams > 1) {
	    calcMultVarSizes();
	} else {
	    calcSizes();
	}
	_size = "size";
    } else {
	if (paramCount > 0)
	    _size = "sizeof(struct __gllc_" functionName "_Rec)";
	else
	    _size = "0";
    }
    if (supportDoubles && needAlign)
	alloc = "2";
    else
	alloc = "";
    printf("    data = (struct __gllc_%s_Rec *) __glSPDlalloc%s(%s, __glop_%s);\n", functionName, alloc, _size, opcodeName);
    printf("    if (data == NULL) return;\n");

#    if (needAlign)
#	printf("    dlop->aligned = GL_TRUE;\n");

    if (paramCount > 0) {
	for (i=1; i<=paramCount; i++) {
	    param = paramName[i];
	    if (_varsize[i]) continue;
	    if (isarray[i]) {
		if (_acount[i] + 0 <= 4) { # coerce _acount[] to number
		    # few enough entries we inline copy them
		    for (j=0; j<_acount[i]; j++) {
			printf("    data->%s[%d] = %s[%d];\n", param, j, 
				param, j);
		    }
		} else {
		    # Just copy the array
		    printf("    __GL_MEMCOPY(data->%s, %s, (int)sizeof(data->%s));\n", 
			    param, param, param);
		}
	    } else {
		printf("    data->%s = %s;\n", param, param);
	    }
	}
	if (varsize) {
	    # Copy the array
	    if (numInVarParams > 1) {
		for (i=0; i<numInVarParams; i++) {
		    printf("    __GL_MEMCOPY((GLubyte *)data + ");
		    printf("(int)sizeof(struct __gllc_%s", functionName);
		    printf("_Rec)%s,\n\t    %s, ", 
					inVarParamOffset[inVarParams[i]], 
					paramName[inVarParams[i]]);
		    printf("arraySize%d);\n", i);
		}
	    } else {
		printf("    __GL_MEMCOPY((GLubyte *)data + (int)sizeof(struct __gllc_%s", functionName);
		printf("_Rec),\n\t    %s, arraySize);\n", paramName[varparam]);
	    }
	}
    }
    printf("}\n\n");
}

function outputCompileAndExecuteFuncs() {
    if (functionName ~ /^(EndList|CallList|CallLists|DrawArrays|DrawArraysEXT|ArrayElement|ArrayElementEXT)$/) {
        return;
    }
# Try replacing with a regexp - JPL
#    if (functionName == "EndList" || functionName == "CallList" ||
#        functionName == "CallLists" || functionName == "DrawArrays" ||
#        functionName == "ArrayElement" || functionName == "DrawArraysEXT" ||
#	functionName == "ArrayElementEXT") {
#        return;

    if (returnType == "GLstring") returnType = "const GLubyte *";

    printf("%s GLAPI __glce_%s(", returnType, functionName);
    outputCArglist();
    printf(")\n");

    printf("{\n");

    if (returnType != "void")
	printf("    %s r;\n", returnType);
    printf("    GLvoid *save;\n");
    printf("    __GL_SETUP();\n\n");

    if ("extension" in propList) {
	if (("extension", "WINSOFT") in propListValues) {
	    tab = "extensions";
	}
    } else {
	tab = "dispatch";
    }

    # save ourselves
    if (functionName !~ /^EndList/) {
	printf("    save = __gl_dispatch.dispatch.%s;\n", functionName);
    }

    if (!(("dlflags", "notlistable") in propListValues)) {
	# first install the compile function
	printf("    __gl_dispatch.dispatch.%s = gc->listCompState.%s;\n",
		functionName, functionName);
	printf("    (*__gl_dispatch.dispatch.%s)(", functionName);
	outputCOldArglist();
	printf(");\n");
#	printf("    gl%s(", functionName);
#	    outputCOldArglist();
#	printf(");\n");
    }

    # next install the immediate mode function
    printf("    __gl_dispatch.dispatch.%s = gc->savedDispatchState.%s;\n",
		functionName, functionName);
    if (returnType != "void") {
        printf("    r = (*__gl_dispatch.dispatch.%s)(", functionName);
    } else {
        printf("    (*__gl_dispatch.dispatch.%s)(", functionName);
    }
    outputCOldArglist();
    printf(");\n");
#    if (returnType != "void")
#	printf("    r = gl%s(", functionName);
#    else
#	printf("    gl%s(", functionName);
#    outputCOldArglist();
#    printf(");\n");

    # reinstall ourselves
    if (functionName !~ /^EndList/) {
	printf("    __gl_dispatch.dispatch.%s = save;\n", functionName);
    }
    if (returnType != "void")
	printf("    return r;\n");
    printf("}\n\n");
}

function outputCompileAndExecuteTable() {
    if ("extension" in propList) {
	if (("extension", "WINSOFT") in propListValues) {
	    extTable[extEntryNumber++] = functionName;
	}
	return;
    }
    otherTable[otherEntryNumber++] = functionName;
}

function finishCompileAndExecuteTable() {
    doTable("__glce_dispatchState", "__glce_");
    # This may seem odd.  we print out a pointer to the table which will
    # be used to initialize the context.  Then if we're doing the old-style
    # stuff, we can just declare the pointer as void and we save the bloat
    # of keeping the table around.
    print "__GLdispatchState *__pglce_dispatchState = ";
    print "&__glce_dispatchState;";
}

function finishApiTable() {
    doTable("__gl_apiDispatchState", "gl");
}

function doTable(name, pref) {
    printf ("__GLdispatchState %s = {\n", name);
    for(i = 0; i < otherEntryNumber; i++) {
        printf("    %s%s,\n", pref, otherTable[i]);
    }
    printf("};\n\n");
}  

function outputHeader_SP() {
    if (("dlflags", "notlistable") in propListValues) return;
    if (returnType == "GLstring") {
       returnType = "const GLubyte *";
    }

    printf "extern %s GLAPI %s%s", returnType, "__glsplc_", functionName;
    printf "( ";
    outputCPrototype();
    printf ");\n";
}

##############################################################################
#
# Print out the appropriate information
#
##############################################################################
function main( i, j, param, cmdlen)
{
    if (("extension", "not_implemented") in propListValues) return;

    if (outputSPheader) {
	outputHeader_SP();
	return;
    }

    if (outputCaEFuncs) {
	outputCompileAndExecuteFuncs();
#	return;
    }

    if (outputCaETable) {
	outputCompileAndExecuteTable();
        return;
    }

    if (("dlflags", "notlistable") in propListValues) return;

    # 
    #  CallLists are not placed within compiled list.
    #
    if (functionName ~ /(CallList|CallLists)$/) return;

    #
    # Some functions are converted into vector forms; not in execution
    # list.
    #

    if (functionName ~ /(Light[if]|LightModel[if]|Material[if]|TexParameter[if]|TexEnv[if]|TexGen[dfi])$/) {
	if (!(outputCompile || outputSPComp)) return;
	}

    #
    # Analyze what we can based upon the argument list
    #
    setPerParamFlags();

    #
    # Figure out the size of each array parameter
    #
    computeInCmdSize();
    
    handcode = (("dlflags", "handcode") in propListValues);
    if (functionName ~ /^Begin/) {
	handcode = 1;
    }

    useVectorEquiv = false;
    if (functionName ~ /(Lighti|Lightf|LightModeli|LightModelf|Lighti|Lightf|LightModeli|LightModelf|Materiali|Materialf|TexParameteri|TexParameterf|TexEnvi|TexEnvf|TexGeni|TexGend|TexGenf)$/) {
	 useVectorEquiv = true;
    }

    errorCheckMat = false;

    if (functionName ~ /Material[fi]v/) {
	errorCheckMat = true;
    }

    #
    # Build a structure that describes what the wire data will look like
    #
    if (outputHeader) {
	output_header();
	return;
    }

    if (handcode) return;
    if (outputExecute && ("vectorequiv" in propList)) return;

    if (outputExecute)
	output_execute();
    if (outputCompile)
	output_compile();
    if (outputSPComp)
	output_compile_SP();
}
    
function finalize()
{
    if (outputCaETable) 
	finishCompileAndExecuteTable();
    else if (outputCaEFuncs) 
      print ("__GLdispatchState *__pglce_dispatchState = 0;");
    if (outputApiTable)
	finishApiTable();
    if (outputCaETable || outputCaEFuncs || outputSPComp)
	printf("#endif /*NEW_LISTS*/");
}
